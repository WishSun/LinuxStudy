

*.o文件 : 汇编完成后的机器可识别的机器码文件,不可执行
ldd *.out  ： 查看程序所依赖的所有库

makefile 编写规则

1. vim Makefile    //名称一定是Makefile
2. 编写完成Makefile后，直接直线make命令即可生成可执行文件
3. 可声明变量，例: src=main.c child.c  ， 使用$(src)可得到变量的值
4. 预定义变量: "#"  是注释
			   $@   冒号左边要生成的对象名称 例：main: main.c child.c  中的main
			   $<   冒号右边第一个依赖对象 即main.c
			   $^   冒号右边所有的依赖对象 即main.c child.c

5.两个make内部的命令，不是shell命令
  命令wildcard : 获取指定目录下的文件
	 栗子: SRC=$(wildcard ./*.c)  : 获取当前目录下的所有后缀为.c的文件名，并赋值给SRC
	
  命令patsubst : 替换命令，它接收三个参数: 参数1: 替代目标  参数2: 替代后的结果  参数3: 替换文本来源
     栗子: OBJ=$(patsubst %.c, %.o, $(SRC)) : 将SRC中的所有文件名的.c更改为.o，并赋值给OBJ
	       其中%是通配符

6.默认只生成第一个对象，之后的对象并不生成。
  但先要生成目标对象的依赖对象，将所有依赖对象全部生成之后，才会生成最终目标对象。

7.如果要执行Makefile文件中伪对象后面的命令，可以执行make命令时，加上对象名称:
     栗子: make clean , 则执行clean对象下面的命令, 一般这个clean是一个伪对象
	 make 与 make clean 分两步执行

8.伪对象:  .PHONY 声明后面的对象为一个伪对象
    特点:  伪对象没有依赖对象，并且也不生成对象，仅仅执行一下

9.编译链接命令中的
  -c  : 只编译不连接，后面跟.c文件名
  -o  : 编译生成可执行程序或目标代码，后面跟目标对象名字
分屏对比文件
在普通模式下,输入命令   :vnew 所要对比的文件名  回车
                         ctrl + ww 光标在两个对比文件之间跳

objdump -S *.a/*.o  可以查看目标文件的汇编代码


静态库和动态库里面放的都是编译完毕后代码文件
静态库 : 链接时，全部写入可执行代码中
	     静态链接库名以lib为前缀，以.a为后缀，中间是静态库的名字
		 生成静态链接库命令: ar -cr   : ar:是生成静态库的命令，-c 指创建  -r replace当静态库改变时将静态库替换
动态库 : 链接时，将库的位置等信息写入可执行代码中, 等到调用的时候才打开库
		 动态链接库名以lib为前缀，以.so为后缀，中间是动态库的名字
		 生成动态链接库命令: gcc --share -fPIC  连接所有.o文件，  而且生成.o文件时也要加入-fPIC选项
		 动态库必须拷贝放在/usr/lib目录或/lib目录中，才可以使用。如果不想拷贝的话，可以在之前系统lib目录下生成
		 一个动态库的软链接
			软链接命令: sudo ln -s 动态库绝对路径 /usr/lib或/lib

链接静态库: -L../lib  -lstatic_test
	      -L : 指示静态库所在目录
		  -l : 指示静态库叫什么名字(不包括lib前缀和.a后缀)

指定头文件查找目录:
		  -I./inc   : 指示目录为./inc

联合编译
     make -C ./src   : 执行./src目录下的make命令
	 make clean -C ./src  : 执行./src目录下的make clean 命令

作业：
写一个通用的Makefile，通过变量可以编译各种文件: 可执行程序、动态链接库、静态链接库
在vim普通模式下，输入命令
     :!pwd   :暂时去外边执行pwd命令,然后再回到vim编辑环境
tree : 显示目录结构
